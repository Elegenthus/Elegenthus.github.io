<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elegenthus&#39;s blog</title>
    <link>https://Elegenthus.github.io/</link>
    <description>Recent content on Elegenthus&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 02 Nov 2016 17:07:33 +0800</lastBuildDate>
    <atom:link href="https://Elegenthus.github.io/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>hackathon_Match(1)</title>
      <link>https://elegenthus.github.io/post/hackathon_Match%281%29/</link>
      <pubDate>Wed, 02 Nov 2016 17:07:33 +0800</pubDate>
      
      <guid>https://elegenthus.github.io/post/hackathon_Match%281%29/</guid>
      <description>&lt;p&gt;上周末和团队的大大们一起去参加了武汉hackathon，真是一次难忘的体验啊~&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先奉上我们组的产品&lt;a href=&#34;http://match.muxixyz.com&#34;&gt;Match&lt;/a&gt;，这是一款通过输入两个人的豆瓣、网易云音乐、微博和知乎账号，寻找其共同项，最后输出一个匹配指数的产品，下面我将简单总结一下此次用到的一些前端技术。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Match是一个使用vue-router实现页面切换效果的单页web应用，所以我们此次只有一个html页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;/static/main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点是main.js部分，它作为入口文件，规定了路由的含义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Vue from &#39;vue&#39;
import Index from &#39;./componnents/index&#39;
import Result from &#39;./componnents/result&#39;
import VueRouter from &#39;vue-router&#39;
import App from &#39;./componnents/app&#39;;
Vue.use(VueRouter)

const router = new VueRouter({
  mode: &#39;history&#39;,
  base: __dirname,
  routes: [
    { path: &#39;/&#39;, component: Index },
    { path: &#39;/result&#39;, component: Result }
  ]
})

new Vue({
  router,
  el: &#39;#app&#39;,
  render: h =&amp;gt; h(App)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先是引入vue-router，然后调用构造器VueRouter定义了一个新的router，在routes中规定访问路径，并将路径path和组件component一一对应地映射起来，然后将其挂载到一个已经vue初始化好的#app元素上&lt;br&gt;&lt;/p&gt;

&lt;p&gt;我们这次的页面中设置了一个父组件，两个子组件&lt;br&gt;
app.vue为此次的父组件，它这次的主要使命是渲染出背景，match的背景中的星空效果是参考&lt;a href=&#34;http://codepen.io/CKH4/pen/vNyyaL&#34;&gt;Random Pure CSS Parallax Stars&lt;/a&gt; &lt;br&gt;
可是如果将1000多行的css代码直接copy到组件的style标签中，会使该组件页面上的别的样式变得复杂难懂，于是我们在这里将该段css代码放到background.scss中，在用import标签引入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import &amp;quot;../scss/background.scss&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在父组件中我们除了将vue创建的app放上去之外，不要忘记页面样式的reset哦~由于这次我们主要使用到的是input输入框和button，于是我们对它们的样式进行重置，部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html, body{
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  font-family: PingFang SC;
}
input{
  border:0;
  outline: none;
  padding: 0;
}
button{
  border:0;
  padding:0;
  box-sizing: content-box;
  margin: 0;
  background-color: transparent;
  outline: none;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后不要忘记定义一个score对象来储存返回的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default {
  name: &amp;quot;App&amp;quot;,
    data (){
        return {
            score:{}
    }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是父组件的内容，下次我们将会对两个子组件index.vue和result.vue进行详细介绍&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vuetest</title>
      <link>https://elegenthus.github.io/post/vuetest/</link>
      <pubDate>Sat, 22 Oct 2016 17:17:19 +0800</pubDate>
      
      <guid>https://elegenthus.github.io/post/vuetest/</guid>
      <description>&lt;p&gt;这是个人的一点小笔记，记录在学习vue的过程中解决的的一些小需求&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;目标：在一个页面的父组件中发请求，请求API中数据分别返回到两个子组件&lt;br&gt;&lt;br&gt;
假设我们请求的第一个API是一个包含多个对象的数组，其中每一个对象包含如下评论信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {    
    &amp;quot;id&amp;quot;: 1244, 
    &amp;quot;likes&amp;quot;: 0 ,
    &amp;quot;liked&amp;quot;: false, 
    &amp;quot;user_name&amp;quot;: &amp;quot;学而2016&amp;quot;,
    &amp;quot;body&amp;quot;: &amp;quot;比较轻松，期末小组做ppt&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将从这个API中获取每一个对象的body信息并将其显示在页面上&lt;br&gt;&lt;br&gt;
1.首先，我们创建一个part1.vue，这是第一个子组件的页面，在每一个vue组件的页面中，应该有template标签，里面包含页面上显示的内容，有style标签，控制页面的具体样式，有script标签，包含我们对页面上内容的操作。由于我们此次请求信息返回的是一个数组对象，所以我决定在数组中将其以列表的形式展示出来，在template中代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;ul id=&amp;quot;app1&amp;quot;&amp;gt;
      &amp;lt;li v-for = &amp;quot;item in list&amp;quot; &amp;gt;
       {{ item.body }}
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对了，还没有解释，其中的item是我为返回的数组取的名字，这一步是在在script标签中进行的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
    data() {
      return {
        list:[]
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于页面的具体样式这里不做赘述，可自行设定，需要提醒的一点是，若用sass来写的话，应该在style标签内加入lang=&amp;lsquo;sass&amp;rsquo;属性&lt;br&gt;&lt;br&gt;
2.接下来是第二个子组件part2.vue，其格式和part1.vue差不多，不过这个组件里我只想显示API返回的数组中第一个对象中的&amp;rdquo;user_name&amp;rdquo;和&amp;rdquo;id&amp;rdquo;属性，在此设第一个对象为obj，想重点提醒一下的是这两个属性在显示时要被包含在一个div中，因为一个组件中只能有一个并行的div，template中的代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      {{ obj.user_name }}
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
      {{ obj.id }}
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.好了，接下来就是我们的重头戏父组件了，parent.vue &lt;br&gt;
首先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;div v-show=&amp;quot;isLoading&amp;quot;&amp;gt;
        加载中
      &amp;lt;/div&amp;gt;
      &amp;lt;courseInfo ref=&amp;quot;courseInfo&amp;quot;&amp;gt;&amp;lt;/courseInfo&amp;gt;
      &amp;lt;courseComment ref=&amp;quot;comment&amp;quot;&amp;gt;&amp;lt;/courseComment&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  import part1 from &#39;./part1&#39;//把子组件和fecth方法import进来
  import part2 from &#39;./part2&#39;
  import &#39;whatwg-fetch&#39;;

  export default {
    data() {
      return {
        isLoading:true
      }
    },
  	mounted () {
  		let promise1 = fetch(&amp;quot;请求的API的相对路径&amp;quot;).then( (res) =&amp;gt; {
        return res.json()
      })
      let promise2 = fetch(&amp;quot;请求的API的相对路径&amp;quot;)
      .then( (res) =&amp;gt; {
        return res.json()
      })
      Promise.all([promise1, promise2]).then( values =&amp;gt; {
        //console.log(this.$refs.courseInfo.obj)
        this.$refs.courseInfo.list= values[1]
        this.$refs.comment.obj = values[0]
        this.isLoading = false
      })
    },
    components:{
      &amp;quot;courseInfo&amp;quot;:part1,
      &amp;quot;courseComment&amp;quot;:part2
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是几点要注意的地方： &lt;br&gt;&lt;br&gt;
a.由于我们这里还会使用fetch方法请求API所以还要先npm装一下fetch（如果只是在最新版的chrome中就不必如此），具体方法见&lt;a href=&#34;https://github.com/github/fetch&#34;&gt;fetch&lt;/a&gt; &lt;br&gt;&lt;br&gt;
b.data里面我们定义了一个isloding的值，是为了在浏览器还没有请求到数据之前先显示一个加载中的文字or信息提示一下，这个提示页面会一直存在直到所有的信息请求完毕，然后我们把isloading的值改为false转而显示页面应该显示的信息&lt;br&gt;&lt;br&gt;
c.然后开始请求API，由于返回的是数据流，所以用res.json() 把它转换成对象，用promise.all方法对相应的对象进行赋值操作，这里使用了v-ref子组件指定一个索引 ID，这样可以直接访问子组件，详见&lt;a href=&#34;https://vuejs.org.cn/guide/components.html&#34;&gt;vue组件&lt;/a&gt; &lt;br&gt;&lt;br&gt;
d.重点强调一下promise.all是等待其参数全部请求成功返回后才会进行下一步的操作，这就正好满足我们希望两个promise成功就拿掉loading页面转而显示请求到的信息这一要求，我们将会在promise.all后的then中将isloading的值改为false &lt;br&gt;&lt;br&gt;
e.最后不要忘记了在component中注册一下子组件哦，这样才能在相应的template中用标签形式引入。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>